# Diarum 个人 AI 助手技术方案 v3.0

**版本**: 3.0
**日期**: 2026年1月31日
**作者**: Manus AI

## 1. 修订背景

本方案在 v2.0 的基础上，根据用户提出的**统一配置管理**的需求进行深度重构。核心目标是摒弃为不同功能创建新配置表的做法，设计一个**统一、可扩展的用户配置系统**。该系统将作为 Diarum 未来所有功能配置的基础，不仅限于 AI 助手。

## 2. 核心设计：统一配置系统

我们引入了一个基于 **Key-Value 模式**的统一配置系统，该系统具有高度的灵活性和可扩展性，能够集中管理用户的所有个性化设置。

### 2.1. 设计原则

- **统一存储**: 所有用户配置项存储在单一的数据表中。
- **高度可扩展**: 新增配置项无需修改数据库表结构，只需在代码中定义新的 Key 即可。
- **类型安全**: 通过在代码中注册配置元数据，确保配置项的类型安全和默认值的统一管理。
- **集中管理**: 抽象出统一的配置服务层，封装所有配置的读写、加密、缓存和验证逻辑。
- **API 驱动**: 提供一套完整的 RESTful API，用于前端和后端对配置进行增删改查。

### 2.2. 数据库设计：`user_settings` 表

我们不再为 AI 功能创建单独的配置表，而是使用一个名为 `user_settings` 的通用表来存储所有配置。

| 字段 | 类型 | 说明 |
| :--- | :--- | :--- |
| `user_id` | relation | 关联到用户表，确保每个配置都属于一个用户。 |
| `key` | text | 配置项的唯一标识符，采用点分隔命名法（如 `ai.enabled`）。 |
| `value` | json | 配置值，支持字符串、数字、布尔、对象等任意 JSON 兼容类型。 |
| `encrypted` | bool | 标记该配置值是否已加密（如 API Key）。 |

通过在 `(user_id, key)` 上建立唯一索引，我们确保了每个用户对同一个配置项只有一条记录。

### 2.3. 配置项定义

所有配置项都在后端代码中进行集中注册，定义其 Key、默认值、是否加密等元数据。这种方式使得配置项易于管理和查找。

**AI 相关配置项示例**：

| Key | 类型 | 默认值 | 是否加密 |
| :--- | :--- | :--- | :--- |
| `ai.enabled` | bool | `false` | 否 |
| `ai.embedding.base_url` | string | `""` | 否 |
| `ai.embedding.model` | string | `""` | 否 |
| `ai.embedding.api_key` | string | `""` | **是** |
| `ai.llm.base_url` | string | `""` | 否 |
| `ai.llm.model` | string | `""` | 否 |
| `ai.llm.api_key` | string | `""` | **是** |
| `ai.chat.save_history` | bool | `true` | 否 |

## 3. 架构设计

### 3.1. 核心服务层：`ConfigService`

我们设计了一个 `ConfigService` 服务层，作为应用中所有配置管理的唯一入口。它负责：

- **CRUD 操作**: 提供获取、设置、删除配置的统一方法。
- **批量处理**: 支持一次性读写多个配置项，减少数据库交互。
- **缓存**: 内置缓存机制，大幅提升配置读取性能。
- **加解密**: 自动处理敏感配置（如 API Key）的加密和解密。
- **默认值**: 当数据库中不存在某个配置项时，自动返回在代码中注册的默认值。
- **预设模板**: 支持应用预设的配置模板（如一键配置 OpenAI, DeepSeek 等）。

### 3.2. API 接口设计

提供一套完整的 RESTful API 来管理配置，前端通过这些接口与 `ConfigService` 交互。

| Method | Endpoint | 描述 |
| :--- | :--- | :--- |
| `GET` | `/api/v1/settings` | 获取用户的所有或部分配置（支持按前缀筛选）。 |
| `PUT` | `/api/v1/settings/batch` | **批量设置**多个配置项，这是前端保存配置的主要方式。 |
| `GET` | `/api/v1/settings/presets` | 获取所有可用的 AI 配置预设模板。 |
| `POST` | `/api/v1/settings/preset/:name` | 应用指定的预设模板，并设置 API Keys。 |
| `POST` | `/api/v1/settings/test` | 测试 AI 服务的连接是否有效。 |

此外，`/api/v1/user/me` 接口也会在返回用户信息的同时，一并返回该用户的所有配置信息，方便前端在应用加载时一次性获取所有必要数据。

## 4. 实施方案

### 4.1. 后端改造 (Go)

1.  **创建 `user_settings` 集合**: 在 PocketBase 中创建新的 `user_settings` 表。
2.  **实现 `ConfigService`**: 编写配置服务层的完整逻辑，包括数据库交互、缓存、加解密等。
3.  **实现配置注册表**: 在代码中定义所有系统配置项及其元数据。
4.  **实现 API Handlers**: 编写处理配置相关 API 请求的处理器，并将其注册到应用的路由中。
5.  **重构应用逻辑**: 将应用中所有直接读写配置的地方，全部改为通过 `ConfigService` 进行。

### 4.2. 前端改造 (Svelte)

1.  **创建统一 API 客户端**: 封装一个 `settingsAPI` 模块，用于调用后端的配置管理 API。
2.  **重构配置页面**: 重新设计“设置”页面，使其能够动态地展示和修改所有配置项。
    -   AI 配置部分将使用新的 API 来获取预设模板、批量保存设置和测试连接。
3.  **状态管理**: 在前端状态管理库（如 Svelte Stores）中，创建一个 `userSettings` store，在应用启动时通过调用 `/api/v1/user/me` 或 `/api/v1/settings` 来初始化，供所有组件使用。

## 5. 方案优势总结

通过引入统一配置系统，v3.0 方案实现了质的飞跃：

- **终极扩展性**: 未来的任何新功能（如外观主题、通知设置、导出选项等）都可以无缝地集成到这个配置系统中，**无需再创建任何新的数据表**。
- **极简数据库**: 数据库结构变得极其简单和稳定，降低了长期维护的复杂性。
- **代码更清晰**: 所有配置相关的逻辑被收敛到 `ConfigService` 中，使得业务代码与配置管理完全解耦，职责更分明。
- **性能更优**: 通过集中的缓存和批量操作，配置的读写性能得到保障。
- **开发效率更高**: 前后端都通过统一的接口和数据结构进行交互，减少了沟通成本和重复开发。

## 6. 结论

Diarum AI 助手技术方案 v3.0 不仅仅是对 v2.0 的一次简单修订，而是一次**架构层面的战略升级**。通过建立一个健壮、可扩展的统一配置系统，我们为 Diarum 项目的长期发展和功能迭代奠定了坚实的基础。这个方案不仅完美地解决了当前 AI 功能的配置需求，更为未来无限的可能性铺平了道路。
